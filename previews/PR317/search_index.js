var documenterSearchIndex = {"docs":
[{"location":"solvers/api/#Solver-API","page":"Solver API","title":"Solver API","text":"","category":"section"},{"location":"solvers/api/","page":"Solver API","title":"Solver API","text":"DelayDiffEq.jl provides delay differential equation solvers through the method of steps approach. The core algorithm wraps ODE solvers from OrdinaryDiffEq.jl to handle the delays.","category":"page"},{"location":"solvers/api/#Method-of-Steps-Algorithm","page":"Solver API","title":"Method of Steps Algorithm","text":"","category":"section"},{"location":"solvers/api/","page":"Solver API","title":"Solver API","text":"The primary algorithm for solving delay differential equations in DelayDiffEq.jl is MethodOfSteps, which implements the method of steps approach for solving DDEs.","category":"page"},{"location":"solvers/api/#DelayDiffEq.MethodOfSteps","page":"Solver API","title":"DelayDiffEq.MethodOfSteps","text":"MethodOfSteps(alg; constrained = false, fpsolve = NLFunctional())\n\nConstruct an algorithm that solves delay differential equations by the method of steps, where alg is an ODE algorithm from OrdinaryDiffEq.jl upon which the calculation of steps is based.\n\nIf the algorithm is constrained only steps of size at most the minimal delay will be taken. If it is unconstrained, fixed-point iteration fpsolve is applied for step sizes that exceed the minimal delay.\n\nCitations:\n\nGeneral Approach\n\nZivari-Piran, Hossein, and Wayne H. Enright. \"An efficient unified approach for the numerical  solution of delay differential equations.\" Numerical Algorithms 53.2-3 (2010): 397-417.\n\nState-Dependent Delays\n\nS. P. Corwin, D. Sarafyan and S. Thompson in \"DKLAG6: a code based on continuously embedded sixth-order Runge-Kutta methods for the solution of state-dependent functional differential equations\", Applied Numerical Mathematics, 1997.\n\n\n\n\n\n","category":"type"},{"location":"solvers/api/#Algorithm-Properties","page":"Solver API","title":"Algorithm Properties","text":"","category":"section"},{"location":"solvers/api/","page":"Solver API","title":"Solver API","text":"Adaptive: Inherits adaptivity from the underlying ODE solver\nOrder: Depends on the chosen ODE algorithm\nDense Output: Available when the underlying ODE solver supports it\nState-Dependent Delays: Supported through fixed-point iteration","category":"page"},{"location":"solvers/api/#Usage","page":"Solver API","title":"Usage","text":"","category":"section"},{"location":"solvers/api/#Basic-Usage","page":"Solver API","title":"Basic Usage","text":"","category":"section"},{"location":"solvers/api/","page":"Solver API","title":"Solver API","text":"using DelayDiffEq, OrdinaryDiffEq\n\n# Use with any ODE solver from OrdinaryDiffEq.jl\nalg = MethodOfSteps(Tsit5())\nsol = solve(prob, alg)","category":"page"},{"location":"solvers/api/#Constrained-vs-Unconstrained","page":"Solver API","title":"Constrained vs Unconstrained","text":"","category":"section"},{"location":"solvers/api/","page":"Solver API","title":"Solver API","text":"By default, MethodOfSteps is unconstrained, meaning it can take steps larger than the minimal delay using fixed-point iteration:","category":"page"},{"location":"solvers/api/","page":"Solver API","title":"Solver API","text":"# Unconstrained (default) - can take larger steps\nalg = MethodOfSteps(Tsit5())\n\n# Constrained - steps limited to minimal delay\nalg = MethodOfSteps(Tsit5(); constrained = true)","category":"page"},{"location":"solvers/api/#Custom-Fixed-Point-Solver","page":"Solver API","title":"Custom Fixed-Point Solver","text":"","category":"section"},{"location":"solvers/api/","page":"Solver API","title":"Solver API","text":"For unconstrained problems, you can specify the fixed-point iteration method:","category":"page"},{"location":"solvers/api/","page":"Solver API","title":"Solver API","text":"# Use custom fixed-point solver\nalg = MethodOfSteps(Tsit5(); fpsolve = NLFunctional(; max_iter = 100))","category":"page"},{"location":"solvers/api/#Recommended-Algorithms","page":"Solver API","title":"Recommended Algorithms","text":"","category":"section"},{"location":"solvers/api/","page":"Solver API","title":"Solver API","text":"The choice of underlying ODE algorithm depends on your problem characteristics:","category":"page"},{"location":"solvers/api/#Non-Stiff-Problems","page":"Solver API","title":"Non-Stiff Problems","text":"","category":"section"},{"location":"solvers/api/","page":"Solver API","title":"Solver API","text":"For non-stiff delay differential equations:","category":"page"},{"location":"solvers/api/","page":"Solver API","title":"Solver API","text":"MethodOfSteps(Tsit5()): Good general purpose solver (5th order)\nMethodOfSteps(BS3()): For lower accuracy requirements (3rd order)\nMethodOfSteps(Vern6()): For high accuracy requirements (6th order)\nMethodOfSteps(Vern9()): For very high accuracy requirements (9th order)","category":"page"},{"location":"solvers/api/#Stiff-Problems","page":"Solver API","title":"Stiff Problems","text":"","category":"section"},{"location":"solvers/api/","page":"Solver API","title":"Solver API","text":"For stiff delay differential equations:","category":"page"},{"location":"solvers/api/","page":"Solver API","title":"Solver API","text":"MethodOfSteps(Rosenbrock23()): Good for mildly stiff problems\nMethodOfSteps(Rodas4()): General purpose stiff solver\nMethodOfSteps(Rodas5()): High accuracy stiff solver\nMethodOfSteps(KenCarp4()): Good stability properties","category":"page"},{"location":"solvers/api/#Low-Storage-Requirements","page":"Solver API","title":"Low Storage Requirements","text":"","category":"section"},{"location":"solvers/api/","page":"Solver API","title":"Solver API","text":"For problems with memory constraints:","category":"page"},{"location":"solvers/api/","page":"Solver API","title":"Solver API","text":"MethodOfSteps(SSPRK104()): Strong stability preserving, low storage\nMethodOfSteps(OwrenZen3()): 3rd order low storage\nMethodOfSteps(OwrenZen5()): 5th order low storage","category":"page"},{"location":"solvers/api/#Algorithm-Selection-Guide","page":"Solver API","title":"Algorithm Selection Guide","text":"","category":"section"},{"location":"solvers/api/#Step-1:-Determine-Stiffness","page":"Solver API","title":"Step 1: Determine Stiffness","text":"","category":"section"},{"location":"solvers/api/","page":"Solver API","title":"Solver API","text":"First, determine if your DDE is stiff. Signs of stiffness include:","category":"page"},{"location":"solvers/api/","page":"Solver API","title":"Solver API","text":"Explicit methods require very small time steps\nThe solution has multiple time scales\nThere are rapid transients followed by slow dynamics","category":"page"},{"location":"solvers/api/#Step-2:-Choose-Tolerance","page":"Solver API","title":"Step 2: Choose Tolerance","text":"","category":"section"},{"location":"solvers/api/","page":"Solver API","title":"Solver API","text":"High tolerance (>1e-2): Use lower order methods\nMedium tolerance (1e-8 to 1e-2): Use standard 4-5 order methods  \nLow tolerance (<1e-8): Use high order methods","category":"page"},{"location":"solvers/api/#Step-3:-Consider-Problem-Structure","page":"Solver API","title":"Step 3: Consider Problem Structure","text":"","category":"section"},{"location":"solvers/api/","page":"Solver API","title":"Solver API","text":"Discontinuous forcing: Use low order methods or constrained stepping\nState-dependent delays: May benefit from constrained stepping\nConservation properties needed: Consider symplectic integrators","category":"page"},{"location":"solvers/api/#Example-Selection","page":"Solver API","title":"Example Selection","text":"","category":"section"},{"location":"solvers/api/","page":"Solver API","title":"Solver API","text":"# Non-stiff problem with medium accuracy\nalg = MethodOfSteps(Tsit5())\n\n# Stiff problem with medium accuracy\nalg = MethodOfSteps(Rodas4())\n\n# High accuracy non-stiff problem\nalg = MethodOfSteps(Vern9())\n\n# Problem with frequent discontinuities\nalg = MethodOfSteps(BS3(); constrained = true)","category":"page"},{"location":"solvers/api/#Performance-Tips","page":"Solver API","title":"Performance Tips","text":"","category":"section"},{"location":"solvers/api/","page":"Solver API","title":"Solver API","text":"Use constrained stepping when delays are much smaller than the timescale of the solution\nChoose higher order methods for smooth problems with stringent accuracy requirements\nUse lower order methods when the solution has many discontinuities\nMonitor the number of fixed-point iterations for unconstrained problems with state-dependent delays","category":"page"},{"location":"solvers/api/#See-Also","page":"Solver API","title":"See Also","text":"","category":"section"},{"location":"solvers/api/","page":"Solver API","title":"Solver API","text":"OrdinaryDiffEq.jl Solver Documentation for details on the underlying ODE solvers\nDifferentialEquations.jl DDE Tutorial for comprehensive examples","category":"page"},{"location":"#DelayDiffEq.jl:-Delay-Differential-Equation-Solvers","page":"DelayDiffEq.jl: DDE solvers","title":"DelayDiffEq.jl: Delay Differential Equation Solvers","text":"","category":"section"},{"location":"","page":"DelayDiffEq.jl: DDE solvers","title":"DelayDiffEq.jl: DDE solvers","text":"DelayDiffEq.jl is a component package of the DifferentialEquations.jl ecosystem for solving delay differential equations (DDEs). It provides the core algorithms and method of steps implementations for solving DDEs with both constant and state-dependent delays.","category":"page"},{"location":"#Features","page":"DelayDiffEq.jl: DDE solvers","title":"Features","text":"","category":"section"},{"location":"","page":"DelayDiffEq.jl: DDE solvers","title":"DelayDiffEq.jl: DDE solvers","text":"Method of steps algorithms with automatic step size control\nSupport for both constant and state-dependent delays\nCompatible with all ODE solvers from OrdinaryDiffEq.jl\nAutomatic discontinuity tracking for accurate solutions\nFull compatibility with the DifferentialEquations.jl common interface","category":"page"},{"location":"#Installation","page":"DelayDiffEq.jl: DDE solvers","title":"Installation","text":"","category":"section"},{"location":"","page":"DelayDiffEq.jl: DDE solvers","title":"DelayDiffEq.jl: DDE solvers","text":"To install DelayDiffEq.jl, use the Julia package manager:","category":"page"},{"location":"","page":"DelayDiffEq.jl: DDE solvers","title":"DelayDiffEq.jl: DDE solvers","text":"using Pkg\nPkg.add(\"DelayDiffEq\")","category":"page"},{"location":"#Quick-Example","page":"DelayDiffEq.jl: DDE solvers","title":"Quick Example","text":"","category":"section"},{"location":"","page":"DelayDiffEq.jl: DDE solvers","title":"DelayDiffEq.jl: DDE solvers","text":"using DelayDiffEq, Plots\n\n# Define a DDE with constant delay\nfunction bc_model(du,u,h,p,t)\n    du[1] = 1.1/(1 + sqrt(10)*(h(p, t-20)[1])^(5/4)) - 10*u[1]/(1 + 40*u[2])\n    du[2] = 100*u[1]/(1 + 40*u[2]) - 2.43*u[2]\nend\n\nh(p, t) = ones(2)\ntspan = (0.0,100.0)\nu0 = [1.05767027/3, 1.030713491/3]\n\nprob = DDEProblem(bc_model,u0,h,tspan; constant_lags=[20.0])\nsol = solve(prob,MethodOfSteps(Tsit5()))\nplot(sol)","category":"page"},{"location":"#Getting-Started","page":"DelayDiffEq.jl: DDE solvers","title":"Getting Started","text":"","category":"section"},{"location":"","page":"DelayDiffEq.jl: DDE solvers","title":"DelayDiffEq.jl: DDE solvers","text":"For more examples and tutorials, see the DifferentialEquations.jl DDE tutorial.","category":"page"},{"location":"","page":"DelayDiffEq.jl: DDE solvers","title":"DelayDiffEq.jl: DDE solvers","text":"For the list of available algorithms and their properties, see the Solver API documentation.","category":"page"}]
}
