var documenterSearchIndex = {"docs":
[{"location":"solvers/api/#Solver-API","page":"Solver API","title":"Solver API","text":"DelayDiffEq.jl provides delay differential equation solvers through the method of steps approach. The core algorithm wraps ODE solvers from OrdinaryDiffEq.jl to handle the delays.","category":"section"},{"location":"solvers/api/#Method-of-Steps-Algorithm","page":"Solver API","title":"Method of Steps Algorithm","text":"The primary algorithm for solving delay differential equations in DelayDiffEq.jl is MethodOfSteps, which implements the method of steps approach for solving DDEs.","category":"section"},{"location":"solvers/api/#Algorithm-Properties","page":"Solver API","title":"Algorithm Properties","text":"Adaptive: Inherits adaptivity from the underlying ODE solver\nOrder: Depends on the chosen ODE algorithm\nDense Output: Available when the underlying ODE solver supports it\nState-Dependent Delays: Supported through fixed-point iteration","category":"section"},{"location":"solvers/api/#Usage","page":"Solver API","title":"Usage","text":"","category":"section"},{"location":"solvers/api/#Basic-Usage","page":"Solver API","title":"Basic Usage","text":"using DelayDiffEq, OrdinaryDiffEq\n\n# Use with any ODE solver from OrdinaryDiffEq.jl\nalg = MethodOfSteps(Tsit5())\nsol = solve(prob, alg)","category":"section"},{"location":"solvers/api/#Constrained-vs-Unconstrained","page":"Solver API","title":"Constrained vs Unconstrained","text":"By default, MethodOfSteps is unconstrained, meaning it can take steps larger than the minimal delay using fixed-point iteration:\n\n# Unconstrained (default) - can take larger steps\nalg = MethodOfSteps(Tsit5())\n\n# Constrained - steps limited to minimal delay\nalg = MethodOfSteps(Tsit5(); constrained = true)","category":"section"},{"location":"solvers/api/#Custom-Fixed-Point-Solver","page":"Solver API","title":"Custom Fixed-Point Solver","text":"For unconstrained problems, you can specify the fixed-point iteration method:\n\n# Use custom fixed-point solver\nalg = MethodOfSteps(Tsit5(); fpsolve = NLFunctional(; max_iter = 100))","category":"section"},{"location":"solvers/api/#Recommended-Algorithms","page":"Solver API","title":"Recommended Algorithms","text":"The choice of underlying ODE algorithm depends on your problem characteristics:","category":"section"},{"location":"solvers/api/#Non-Stiff-Problems","page":"Solver API","title":"Non-Stiff Problems","text":"For non-stiff delay differential equations:\n\nMethodOfSteps(Tsit5()): Good general purpose solver (5th order)\nMethodOfSteps(BS3()): For lower accuracy requirements (3rd order)\nMethodOfSteps(Vern6()): For high accuracy requirements (6th order)\nMethodOfSteps(Vern9()): For very high accuracy requirements (9th order)","category":"section"},{"location":"solvers/api/#Stiff-Problems","page":"Solver API","title":"Stiff Problems","text":"For stiff delay differential equations:\n\nMethodOfSteps(Rosenbrock23()): Good for mildly stiff problems\nMethodOfSteps(Rodas4()): General purpose stiff solver\nMethodOfSteps(Rodas5()): High accuracy stiff solver\nMethodOfSteps(KenCarp4()): Good stability properties","category":"section"},{"location":"solvers/api/#Low-Storage-Requirements","page":"Solver API","title":"Low Storage Requirements","text":"For problems with memory constraints:\n\nMethodOfSteps(SSPRK104()): Strong stability preserving, low storage\nMethodOfSteps(OwrenZen3()): 3rd order low storage\nMethodOfSteps(OwrenZen5()): 5th order low storage","category":"section"},{"location":"solvers/api/#Algorithm-Selection-Guide","page":"Solver API","title":"Algorithm Selection Guide","text":"","category":"section"},{"location":"solvers/api/#Step-1:-Determine-Stiffness","page":"Solver API","title":"Step 1: Determine Stiffness","text":"First, determine if your DDE is stiff. Signs of stiffness include:\n\nExplicit methods require very small time steps\nThe solution has multiple time scales\nThere are rapid transients followed by slow dynamics","category":"section"},{"location":"solvers/api/#Step-2:-Choose-Tolerance","page":"Solver API","title":"Step 2: Choose Tolerance","text":"High tolerance (>1e-2): Use lower order methods\nMedium tolerance (1e-8 to 1e-2): Use standard 4-5 order methods  \nLow tolerance (<1e-8): Use high order methods","category":"section"},{"location":"solvers/api/#Step-3:-Consider-Problem-Structure","page":"Solver API","title":"Step 3: Consider Problem Structure","text":"Discontinuous forcing: Use low order methods or constrained stepping\nState-dependent delays: May benefit from constrained stepping\nConservation properties needed: Consider symplectic integrators","category":"section"},{"location":"solvers/api/#Example-Selection","page":"Solver API","title":"Example Selection","text":"# Non-stiff problem with medium accuracy\nalg = MethodOfSteps(Tsit5())\n\n# Stiff problem with medium accuracy\nalg = MethodOfSteps(Rodas4())\n\n# High accuracy non-stiff problem\nalg = MethodOfSteps(Vern9())\n\n# Problem with frequent discontinuities\nalg = MethodOfSteps(BS3(); constrained = true)","category":"section"},{"location":"solvers/api/#Performance-Tips","page":"Solver API","title":"Performance Tips","text":"Use constrained stepping when delays are much smaller than the timescale of the solution\nChoose higher order methods for smooth problems with stringent accuracy requirements\nUse lower order methods when the solution has many discontinuities\nMonitor the number of fixed-point iterations for unconstrained problems with state-dependent delays","category":"section"},{"location":"solvers/api/#See-Also","page":"Solver API","title":"See Also","text":"OrdinaryDiffEq.jl Solver Documentation for details on the underlying ODE solvers\nDifferentialEquations.jl DDE Tutorial for comprehensive examples","category":"section"},{"location":"solvers/api/#DelayDiffEq.MethodOfSteps","page":"Solver API","title":"DelayDiffEq.MethodOfSteps","text":"MethodOfSteps(alg; constrained = false, fpsolve = NLFunctional())\n\nConstruct an algorithm that solves delay differential equations by the method of steps, where alg is an ODE algorithm from OrdinaryDiffEq.jl upon which the calculation of steps is based.\n\nIf the algorithm is constrained only steps of size at most the minimal delay will be taken. If it is unconstrained, fixed-point iteration fpsolve is applied for step sizes that exceed the minimal delay.\n\nCitations:\n\nGeneral Approach\n\nZivari-Piran, Hossein, and Wayne H. Enright. \"An efficient unified approach for the numerical  solution of delay differential equations.\" Numerical Algorithms 53.2-3 (2010): 397-417.\n\nState-Dependent Delays\n\nS. P. Corwin, D. Sarafyan and S. Thompson in \"DKLAG6: a code based on continuously embedded sixth-order Runge-Kutta methods for the solution of state-dependent functional differential equations\", Applied Numerical Mathematics, 1997.\n\n\n\n\n\n","category":"type"},{"location":"#DelayDiffEq.jl:-Delay-Differential-Equation-Solvers","page":"DelayDiffEq.jl: DDE solvers","title":"DelayDiffEq.jl: Delay Differential Equation Solvers","text":"DelayDiffEq.jl is a component package of the DifferentialEquations.jl ecosystem for solving delay differential equations (DDEs). It provides the core algorithms and method of steps implementations for solving DDEs with both constant and state-dependent delays.","category":"section"},{"location":"#Features","page":"DelayDiffEq.jl: DDE solvers","title":"Features","text":"Method of steps algorithms with automatic step size control\nSupport for both constant and state-dependent delays\nCompatible with all ODE solvers from OrdinaryDiffEq.jl\nAutomatic discontinuity tracking for accurate solutions\nFull compatibility with the DifferentialEquations.jl common interface","category":"section"},{"location":"#Installation","page":"DelayDiffEq.jl: DDE solvers","title":"Installation","text":"To install DelayDiffEq.jl, use the Julia package manager:\n\nusing Pkg\nPkg.add(\"DelayDiffEq\")","category":"section"},{"location":"#Quick-Example","page":"DelayDiffEq.jl: DDE solvers","title":"Quick Example","text":"using DelayDiffEq, Plots\n\n# Define a DDE with constant delay\nfunction bc_model(du,u,h,p,t)\n    du[1] = 1.1/(1 + sqrt(10)*(h(p, t-20)[1])^(5/4)) - 10*u[1]/(1 + 40*u[2])\n    du[2] = 100*u[1]/(1 + 40*u[2]) - 2.43*u[2]\nend\n\nh(p, t) = ones(2)\ntspan = (0.0,100.0)\nu0 = [1.05767027/3, 1.030713491/3]\n\nprob = DDEProblem(bc_model,u0,h,tspan; constant_lags=[20.0])\nsol = solve(prob,MethodOfSteps(Tsit5()))\nplot(sol)","category":"section"},{"location":"#Getting-Started","page":"DelayDiffEq.jl: DDE solvers","title":"Getting Started","text":"For more examples and tutorials, see the DifferentialEquations.jl DDE tutorial.\n\nFor the list of available algorithms and their properties, see the Solver API documentation.","category":"section"}]
}
